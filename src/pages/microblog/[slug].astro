---
import BaseLayout from "../../layouts/BaseLayout.astro";

// Helper functions
function getDateTimeFromPath(path: string): string {
    // Extract date and time from filename like 2023-07-20-00-00
    const match = path.match(
        /(\d{4}-\d{1,2}-\d{1,2})-(\d{1,2})-(\d{1,2})-?(\d{1,2})?/,
    );
    if (match) {
        const [, datePart, hour, minute, second] = match;
        const parts = datePart.split("-");
        const year = parts[0];
        const month = parts[1].padStart(2, "0");
        const day = parts[2].padStart(2, "0");
        const hourPadded = hour.padStart(2, "0");
        const minutePadded = minute.padStart(2, "0");
        const secondPadded = second ? second.padStart(2, "0") : "00";
        return `${year}-${month}-${day}T${hourPadded}:${minutePadded}:${secondPadded}`;
    }
    // Fallback to just date
    const dateMatch = path.match(/(\d{4}-\d{1,2}-\d{1,2})/);
    if (dateMatch) {
        const parts = dateMatch[1].split("-");
        const year = parts[0];
        const month = parts[1].padStart(2, "0");
        const day = parts[2].padStart(2, "0");
        return `${year}-${month}-${day}T00:00:00`;
    }
    return "";
}

function formatMicroblogTitle(dateTimeString: string): string {
    const d = new Date(dateTimeString);
    if (isNaN(d.getTime())) return dateTimeString;

    // Date: Dec 22, 2025
    const datePart = d.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
    });

    // Time: 16:51 (Manual 24h construction)
    const hours = d.getHours().toString().padStart(2, "0");
    const minutes = d.getMinutes().toString().padStart(2, "0");

    return `${datePart}, ${hours}:${minutes}`;
}

function getMicroPostContent(post: any): string {
    try {
        let processedContent = post.rawContent;
        if (!processedContent) return "";

        // 1. Normalize line endings (fixes list issues on Windows/Linux mix)
        processedContent = processedContent.replace(/\r\n/g, "\n");

        // 2. Remove Jekyll specific syntax
        // Matches {{site.url}} or {{ site.url }} with spaces
        processedContent = processedContent.replace(/\{\{\s*site\.url\s*\}\}/g, "");
        // Remove {: .class } style attributes
        processedContent = processedContent.replace(/\{:[^}]+\}/g, "");

        // 3. Convert Markdown Images
        // MUST be done before lists or tooltips
        processedContent = processedContent.replace(
            /!\[([^\]]*)\]\(([^)]+)\)/g,
            '<img src="$2" alt="$1" style="max-width: 100%; height: auto;" class="clickableimg">'
        );

        // 4. Convert Tooltips
        processedContent = processedContent.replace(
            /\(\:\:([^)]+)\)/g,
            '<span class="hover-footnote" data-title="$1">*</span>'
        );

        // 5. Convert Markdown Links
        processedContent = processedContent.replace(
            /\[([^\]]+)\]\(([^)]+)\)/g,
            '<a href="$2">$1</a>'
        );

        // 6. Convert markdown blockquotes: > text -> <blockquote>text</blockquote>
        processedContent = processedContent.replace(
            /^>\s*(.+)$/gm,
            '<blockquote>$1</blockquote>'
        );

        // 7. Handle Lists (The fixed logic)
        // Step A: Convert lines starting with "- " or "* " to <li>
        processedContent = processedContent.replace(
            /^[\s]*[-*]\s+(.*)$/gm,
            '<li>$1</li>'
        );

        // Step B: Wrap consecutive <li> items in <ul>
        processedContent = processedContent.replace(
            /((?:<li>.*<\/li>(?:\n|$))+)/g,
            (match) => {
                // Remove newlines inside the list block so they don't become <br>
                const cleanList = match.replace(/\n/g, "");
                return `<ul>${cleanList}</ul>`;
            }
        );


        // Avoid adding <br> right after blockquotes and images (handle spaces and CRLF)
        processedContent = processedContent.replace(/<\/blockquote>\s*\r?\n+/g, "</blockquote>");
        processedContent = processedContent.replace(/(<img[^>]*>)\s*\r?\n+/g, "$1");

        // 8. Convert remaining newlines to <br> tags
        processedContent = processedContent.replace(/\n/g, "<br>");


        return processedContent;
    } catch (error) {
        return "";
    }
}

export async function getStaticPaths() {
    // Get all microblog post files as raw strings
    const microPostFiles = import.meta.glob("../../posts_micro/*.md", {
        eager: true,
        query: "?raw",
        import: "default",
    });

    // Process microblog posts manually
    const allMicroPosts = Object.entries(microPostFiles)
        .map(([path, rawContent]: [string, string]) => {
            return {
                file: path,
                rawContent: rawContent.trim(),
            };
        })
        .filter((post) => post.rawContent.length > 0);

    // Generate paths for each microblog post
    return allMicroPosts.map((post) => {
        const slug = post.file.split("/").pop()?.replace(".md", "") || "";

        return {
            params: { slug },
            props: {
                post,
                slug,
            },
        };
    });
}

const { post, slug } = Astro.props;
const dateTime = getDateTimeFromPath(post.file);
const content = getMicroPostContent(post);
const pageTitle = formatMicroblogTitle(dateTime);
---

<BaseLayout title={`Microblog - ${pageTitle}`}>
    <!-- Single post container -->
    <div class="post">
        <article class="post-item">
            <header class="post-header">
                <h1 class="post-title">
                    {pageTitle}
                </h1>
            </header>
            <div class="post-content">
                <Fragment set:html={content} />
            </div>
        </article>
    </div>
</BaseLayout>
